{"ast":null,"code":"function ___$insertStyle(css) {\n  if (!css) {\n    return;\n  }\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  var style = document.createElement('style');\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  return css;\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar useStateRef = function useStateRef(initalState) {\n  var _useState = React.useState(initalState),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var ref = React.useRef(initalState);\n\n  var setStateRef = function setStateRef(newState) {\n    setState(newState);\n    ref.current = newState;\n  };\n\n  return [state, setStateRef, ref];\n};\n\n___$insertStyle(\".datalist-input {\\n  /*the container must be positioned relative:*/\\n  position: relative;\\n  display: inline-block;\\n  width: 100%;\\n}\\n\\n.datalist-input .autocomplete-input {\\n  width: 100%;\\n}\\n\\n.datalist-input .datalist-items {\\n  position: absolute;\\n  z-index: 99;\\n  /*position the autocomplete items to be the same width as the container:*/\\n  top: 100%;\\n  left: 0;\\n  right: 0;\\n}\\n\\n.datalist-input .default-datalist-items {\\n  border: 1px solid #d4d4d4;\\n  border-bottom: none;\\n  border-top: none;\\n}\\n\\n.datalist-input .default-datalist-items div:not(.datalist-active-item) {\\n  padding: 10px;\\n  cursor: pointer;\\n  background-color: #fff;\\n  border-bottom: 1px solid #d4d4d4;\\n}\\n\\n.datalist-input .default-datalist-items div:not(.datalist-active-item):hover {\\n  /*when hovering an item:*/\\n  background-color: #e9e9e9;\\n}\\n\\n.datalist-input .datalist-active-item {\\n  /*when navigating through the items using the arrow keys:*/\\n  cursor: pointer;\\n}\\n\\n.datalist-input .datalist-active-item-default {\\n  background-color: DodgerBlue;\\n  color: #ffffff;\\n  border-bottom: 1px solid #d4d4d4;\\n  padding: 10px;\\n}\");\n/**\n * default function for matching the current input value (needle)\n * and the values of the items array\n * @param currentInput\n * @param item\n * @returns {boolean}\n */\n\n\nvar labelMatch = function labelMatch(currentInput, item) {\n  return item.label.substr(0, currentInput.length).toLowerCase() === currentInput.toLowerCase();\n};\n/**\n * function for getting the index of the currentValue inside a value of the values array\n * @param currentInput\n * @param item\n * @returns {number}\n */\n\n\nvar indexOfMatch = function indexOfMatch(currentInput, item) {\n  return item.label.toLowerCase().indexOf(currentInput.toLowerCase());\n};\n/**\n * index of item in items\n * @param {*} item\n * @param {*} items\n */\n\n\nvar indexOfItem = function indexOfItem(item, items) {\n  return items.indexOf(items.find(function (i) {\n    return i.key === item.key;\n  }));\n};\n\nvar DataListInput = function DataListInput(_ref) {\n  var activeItemClassName = _ref.activeItemClassName,\n      clearInputOnSelect = _ref.clearInputOnSelect,\n      clearInputOnClick = _ref.clearInputOnClick,\n      debounceLoader = _ref.debounceLoader,\n      debounceTime = _ref.debounceTime,\n      dropdownClassName = _ref.dropdownClassName,\n      dropDownLength = _ref.dropDownLength,\n      value = _ref.value,\n      inputClassName = _ref.inputClassName,\n      itemClassName = _ref.itemClassName,\n      match = _ref.match,\n      onDropdownClose = _ref.onDropdownClose,\n      onDropdownOpen = _ref.onDropdownOpen,\n      onInput = _ref.onInput,\n      onSelect = _ref.onSelect,\n      onClick = _ref.onClick,\n      placeholder = _ref.placeholder,\n      requiredInputLength = _ref.requiredInputLength,\n      suppressReselect = _ref.suppressReselect,\n      items = _ref.items;\n  /*  last valid item that was selected from the drop down menu */\n\n  var _useState = React.useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      lastValidItem = _useState2[0],\n      setLastValidItem = _useState2[1];\n  /* current input text */\n\n\n  var _useStateRef = useStateRef(value !== undefined ? value : ''),\n      _useStateRef2 = _slicedToArray(_useStateRef, 3),\n      currentInput = _useStateRef2[0],\n      setCurrentInput = _useStateRef2[1],\n      currentInputRef = _useStateRef2[2];\n  /* current set of matching items */\n\n\n  var _useState3 = React.useState([]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      matchingItems = _useState4[0],\n      setMatchingItems = _useState4[1];\n  /* visibility property of the drop down menu */\n\n\n  var _useStateRef3 = useStateRef(false),\n      _useStateRef4 = _slicedToArray(_useStateRef3, 3),\n      visible = _useStateRef4[0],\n      setVisible = _useStateRef4[1],\n      visibleRef = _useStateRef4[2];\n  /* index of the currently focused item in the drop down menu */\n\n\n  var _useState5 = React.useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      focusIndex = _useState6[0],\n      setFocusIndex = _useState6[1];\n  /* cleaner click events, click interaction within dropdown menu */\n\n\n  var interactionHappenedRef = React.useRef(false);\n  /* show loader if still matching in debounced mode */\n\n  var _useState7 = React.useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      isMatchingDebounced = _useState8[0],\n      setIsMatchingDebounced = _useState8[1];\n  /* to manage debouncing of matching, typing input into the input field */\n\n\n  var inputHappenedTimeout = React.useRef();\n  var menu = React.useRef();\n  var inputField = React.useRef();\n  React.useEffect(function () {\n    var onClickCloseMenu = function onClickCloseMenu(event) {\n      if (!menu.current) return; // if rerender, items inside might change, allow one click without further checking\n\n      if (interactionHappenedRef.current) {\n        interactionHappenedRef.current = false;\n        return;\n      } // do not do anything if input is clicked, as we have a dedicated func for that\n\n\n      if (!inputField.current) return;\n      var targetIsInput = event.target === inputField.current;\n      var targetInInput = inputField.current.contains(event.target);\n      if (targetIsInput || targetInInput) return; // do not close menu if user clicked inside\n\n      var targetInMenu = menu.current.contains(event.target);\n      var targetIsMenu = event.target === menu.current;\n      if (targetInMenu || targetIsMenu) return;\n\n      if (visibleRef.current) {\n        setVisible(false);\n        setFocusIndex(-1);\n        onDropdownClose();\n      }\n    };\n\n    window.addEventListener('click', onClickCloseMenu, false);\n    return function () {\n      window.removeEventListener('click', onClickCloseMenu);\n    };\n  }, [onDropdownClose, setVisible, visibleRef]);\n  React.useEffect(function () {\n    // the parent component can pass its own value prop that will override the internally used currentInput\n    // this will happen only after we are have finished the current computing step and the dropdown is invisible\n    // (to avoid confusion of changing input values for the user)\n\n    /*\n     * we have to distinguish undefined and empty string value\n     * value == undefined => not set, use internal current input\n     * value !== undefined => value set, use value and override currentInput\n     * this enables value === '' to clear the input field\n     */\n    var isValuePropSet = value !== undefined;\n    var isValueDifferent = currentInputRef.current !== value;\n    var isMatchingRunning = visible || isMatchingDebounced;\n\n    if (isValuePropSet && isValueDifferent && !isMatchingRunning) {\n      setCurrentInput(value);\n    }\n  }, [visible, isMatchingDebounced, value, setCurrentInput, currentInputRef]);\n  /**\n   * runs the matching process of the current input\n   * and handles debouncing the different callback calls to reduce lag time\n   * for bigger datasets or heavier matching algorithms\n   * @param nextInput\n   */\n\n  var debouncedMatchingUpdateStep = React.useCallback(function (nextInput) {\n    // cleanup waiting update step\n    if (inputHappenedTimeout.current) {\n      clearTimeout(inputHappenedTimeout.current);\n      inputHappenedTimeout.current = null;\n    } // set nextInput into input field and show loading if debounced mode is on\n\n\n    var reachedRequiredLength = nextInput.length >= requiredInputLength;\n    var showMatchingStillLoading = debounceTime >= 0 && reachedRequiredLength;\n    setCurrentInput(nextInput);\n    setIsMatchingDebounced(showMatchingStillLoading); // no matching if we do not reach required input length\n\n    if (!reachedRequiredLength) return;\n\n    var updateMatchingItems = function updateMatchingItems() {\n      // matching process to find matching entries in items array\n      var updatedMatchingItems = items.filter(function (item) {\n        if (_typeof(match) === (typeof Function === \"undefined\" ? \"undefined\" : _typeof(Function))) return match(nextInput, item);\n        return labelMatch(nextInput, item);\n      });\n      var displayableItems = updatedMatchingItems.slice(0, dropDownLength);\n      var showDragIndex = lastValidItem && !clearInputOnSelect;\n      var index = showDragIndex ? indexOfItem(lastValidItem, displayableItems) : 0;\n\n      if (displayableItems.length) {\n        if (!visibleRef.current) {\n          onDropdownOpen();\n        }\n\n        setMatchingItems(displayableItems);\n        setFocusIndex(index > 0 ? index : 0);\n        setIsMatchingDebounced(false);\n        setVisible(true);\n      } else {\n        if (visibleRef.current) {\n          setVisible(false);\n          onDropdownClose();\n        }\n\n        setMatchingItems(displayableItems);\n        setFocusIndex(-1);\n        setIsMatchingDebounced(false);\n      }\n    };\n\n    if (debounceTime <= 0) {\n      updateMatchingItems();\n    } else {\n      inputHappenedTimeout.current = setTimeout(updateMatchingItems, debounceTime);\n    }\n  }, [requiredInputLength, debounceTime, setCurrentInput, items, dropDownLength, lastValidItem, clearInputOnSelect, match, setVisible, onDropdownOpen, visibleRef, onDropdownClose]);\n  /**\n   * gets called when someone starts to write in the input field\n   * @param event\n   */\n\n  var onHandleInput = React.useCallback(function (event) {\n    var newValue = event.target.value;\n    debouncedMatchingUpdateStep(newValue);\n    onInput(newValue);\n  }, [debouncedMatchingUpdateStep, onInput]);\n  var onClickInput = React.useCallback(function () {\n    var currentValue = currentInputRef.current; // if user clicks on input field with value,\n    // the user most likely wants to clear the input field\n\n    if (currentValue && clearInputOnClick) {\n      currentValue = '';\n    }\n\n    onClick(currentValue);\n    var reachedRequiredLength = currentValue.length >= requiredInputLength;\n\n    if (reachedRequiredLength && !visibleRef.current) {\n      debouncedMatchingUpdateStep(currentValue);\n    }\n  }, [currentInputRef, clearInputOnClick, onClick, requiredInputLength, visibleRef, debouncedMatchingUpdateStep]);\n  /**\n   * handleSelect is called onClickItem and onEnter upon an option of the drop down menu\n   * does nothing if the key has not changed since the last onSelect event\n   * @param selectedItem\n   */\n\n  var onHandleSelect = React.useCallback(function (selectedItem) {\n    // block select call until last matching went through\n    if (isMatchingDebounced) return;\n    setCurrentInput(clearInputOnSelect ? '' : selectedItem.label);\n    setVisible(false);\n    setFocusIndex(-1);\n    interactionHappenedRef.current = true;\n    onDropdownClose();\n\n    if (suppressReselect && lastValidItem && selectedItem.key === lastValidItem.key) {\n      // do not trigger the callback function\n      // but still change state to fit new selection\n      return;\n    } // change state to fit new selection\n\n\n    setLastValidItem(selectedItem); // callback function onSelect\n\n    onSelect(selectedItem);\n  }, [isMatchingDebounced, setCurrentInput, clearInputOnSelect, setVisible, onDropdownClose, suppressReselect, lastValidItem, onSelect]);\n  /**\n   * handle key events\n   * @param event\n   */\n\n  var onHandleKeydown = React.useCallback(function (event) {\n    // only do something if drop-down div is visible\n    if (!visibleRef.current) return;\n    var currentFocusIndex = focusIndex;\n\n    if (event.keyCode === 40 || event.keyCode === 9) {\n      // If the arrow DOWN key or tab is pressed increase the currentFocus variable:\n      currentFocusIndex += 1;\n      if (currentFocusIndex >= matchingItems.length) currentFocusIndex = 0;\n      setFocusIndex(currentFocusIndex); // prevent tab to jump to the next input field if drop down is still open\n\n      event.preventDefault();\n    } else if (event.keyCode === 38) {\n      // If the arrow UP key is pressed, decrease the currentFocus variable:\n      currentFocusIndex -= 1;\n      if (currentFocusIndex <= -1) currentFocusIndex = matchingItems.length - 1;\n      setFocusIndex(currentFocusIndex);\n    } else if (event.keyCode === 13) {\n      // Enter pressed, similar to onClickItem\n      if (focusIndex > -1) {\n        // Simulate a click on the \"active\" item:\n        var selectedItem = matchingItems[currentFocusIndex];\n        onHandleSelect(selectedItem);\n      }\n    }\n  }, [focusIndex, matchingItems, onHandleSelect, visibleRef]);\n  var renderItemLabel = React.useCallback(function (item) {\n    var index = indexOfMatch(currentInput, item);\n    var inputLength = currentInput.length;\n    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, index >= 0 && inputLength ?\n    /*#__PURE__*/\n    // renders label with matching search string marked\n    React__default.createElement(React__default.Fragment, null, item.label.substr(0, index), /*#__PURE__*/React__default.createElement(\"strong\", null, item.label.substr(index, inputLength)), item.label.substr(index + inputLength, item.label.length)) : item.label);\n  }, [currentInput]);\n  var renderItems = React.useCallback(function () {\n    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, matchingItems.map(function (item, i) {\n      var isActive = focusIndex === i;\n      var itemActiveClasses = isActive ? \"datalist-active-item \".concat(activeItemClassName || 'datalist-active-item-default') : '';\n      var itemClasses = \"\".concat(itemClassName, \" \").concat(itemActiveClasses);\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        onClick: function onClick() {\n          return onHandleSelect(item);\n        },\n        className: itemClasses,\n        key: item.key,\n        tabIndex: 0,\n        role: \"button\",\n        \"aria-label\": item.label,\n        onKeyUp: function onKeyUp(event) {\n          return event.preventDefault();\n        }\n      }, renderItemLabel(item));\n    }));\n  }, [matchingItems, focusIndex, activeItemClassName, itemClassName, onHandleSelect, renderItemLabel]);\n  var dropDown = React.useMemo(function () {\n    var reachedRequiredLength = currentInputRef.current.length >= requiredInputLength;\n\n    if (reachedRequiredLength && isMatchingDebounced) {\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        ref: menu,\n        className: \"datalist-items \".concat(dropdownClassName || 'default-datalist-items'),\n        role: \"dialog\",\n        \"aria-label\": \"Dropdown menu\"\n      }, /*#__PURE__*/React__default.createElement(\"div\", {\n        className: itemClassName\n      }, debounceLoader || 'loading...'));\n    }\n\n    if (reachedRequiredLength && visible) {\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        ref: menu,\n        className: \"datalist-items \".concat(dropdownClassName || 'default-datalist-items'),\n        role: \"dialog\",\n        \"aria-label\": \"Dropdown menu\"\n      }, renderItems());\n    }\n\n    return undefined;\n  }, [currentInputRef, requiredInputLength, isMatchingDebounced, visible, dropdownClassName, itemClassName, debounceLoader, renderItems]);\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"datalist-input\"\n  }, /*#__PURE__*/React__default.createElement(\"input\", {\n    ref: inputField,\n    onChange: onHandleInput,\n    onClick: onClickInput,\n    onKeyDown: onHandleKeydown,\n    type: \"text\",\n    className: \"autocomplete-input \".concat(inputClassName),\n    placeholder: placeholder,\n    value: currentInput,\n    \"aria-label\": \"Search\"\n  }), dropDown);\n};\n\nDataListInput.propTypes = {\n  items: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.string.isRequired,\n    key: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired\n  })).isRequired,\n  placeholder: PropTypes.string,\n  onSelect: PropTypes.func.isRequired,\n  onDropdownOpen: PropTypes.func,\n  onDropdownClose: PropTypes.func,\n  match: PropTypes.func,\n  inputClassName: PropTypes.string,\n  dropdownClassName: PropTypes.string,\n  itemClassName: PropTypes.string,\n  activeItemClassName: PropTypes.string,\n  requiredInputLength: PropTypes.number,\n  clearInputOnSelect: PropTypes.bool,\n  clearInputOnClick: PropTypes.bool,\n  suppressReselect: PropTypes.bool,\n  dropDownLength: PropTypes.number,\n  value: PropTypes.string,\n  debounceTime: PropTypes.number,\n  debounceLoader: PropTypes.node,\n  onInput: PropTypes.func,\n  onClick: PropTypes.func\n};\nDataListInput.defaultProps = {\n  placeholder: '',\n  match: undefined,\n  inputClassName: '',\n  dropdownClassName: '',\n  itemClassName: '',\n  activeItemClassName: '',\n  requiredInputLength: 0,\n  clearInputOnSelect: false,\n  clearInputOnClick: false,\n  suppressReselect: true,\n  dropDownLength: Infinity,\n  value: undefined,\n  debounceTime: 0,\n  debounceLoader: undefined,\n  onDropdownOpen: function onDropdownOpen() {},\n  onDropdownClose: function onDropdownClose() {},\n  onInput: function onInput() {},\n  onClick: function onClick() {}\n};\nexports.default = DataListInput;","map":{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":["\n\nfunction ___$insertStyle(css) {\n  if (!css) {\n    return;\n  }\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  var style = document.createElement('style');\n\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  return css;\n}\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = require('react');\nvar React__default = _interopDefault(React);\nvar PropTypes = _interopDefault(require('prop-types'));\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar useStateRef = function useStateRef(initalState) {\n  var _useState = React.useState(initalState),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  var ref = React.useRef(initalState);\n\n  var setStateRef = function setStateRef(newState) {\n    setState(newState);\n    ref.current = newState;\n  };\n\n  return [state, setStateRef, ref];\n};\n\n___$insertStyle(\".datalist-input {\\n  /*the container must be positioned relative:*/\\n  position: relative;\\n  display: inline-block;\\n  width: 100%;\\n}\\n\\n.datalist-input .autocomplete-input {\\n  width: 100%;\\n}\\n\\n.datalist-input .datalist-items {\\n  position: absolute;\\n  z-index: 99;\\n  /*position the autocomplete items to be the same width as the container:*/\\n  top: 100%;\\n  left: 0;\\n  right: 0;\\n}\\n\\n.datalist-input .default-datalist-items {\\n  border: 1px solid #d4d4d4;\\n  border-bottom: none;\\n  border-top: none;\\n}\\n\\n.datalist-input .default-datalist-items div:not(.datalist-active-item) {\\n  padding: 10px;\\n  cursor: pointer;\\n  background-color: #fff;\\n  border-bottom: 1px solid #d4d4d4;\\n}\\n\\n.datalist-input .default-datalist-items div:not(.datalist-active-item):hover {\\n  /*when hovering an item:*/\\n  background-color: #e9e9e9;\\n}\\n\\n.datalist-input .datalist-active-item {\\n  /*when navigating through the items using the arrow keys:*/\\n  cursor: pointer;\\n}\\n\\n.datalist-input .datalist-active-item-default {\\n  background-color: DodgerBlue;\\n  color: #ffffff;\\n  border-bottom: 1px solid #d4d4d4;\\n  padding: 10px;\\n}\");\n\n/**\n * default function for matching the current input value (needle)\n * and the values of the items array\n * @param currentInput\n * @param item\n * @returns {boolean}\n */\n\nvar labelMatch = function labelMatch(currentInput, item) {\n  return item.label.substr(0, currentInput.length).toLowerCase() === currentInput.toLowerCase();\n};\n/**\n * function for getting the index of the currentValue inside a value of the values array\n * @param currentInput\n * @param item\n * @returns {number}\n */\n\n\nvar indexOfMatch = function indexOfMatch(currentInput, item) {\n  return item.label.toLowerCase().indexOf(currentInput.toLowerCase());\n};\n/**\n * index of item in items\n * @param {*} item\n * @param {*} items\n */\n\n\nvar indexOfItem = function indexOfItem(item, items) {\n  return items.indexOf(items.find(function (i) {\n    return i.key === item.key;\n  }));\n};\n\nvar DataListInput = function DataListInput(_ref) {\n  var activeItemClassName = _ref.activeItemClassName,\n      clearInputOnSelect = _ref.clearInputOnSelect,\n      clearInputOnClick = _ref.clearInputOnClick,\n      debounceLoader = _ref.debounceLoader,\n      debounceTime = _ref.debounceTime,\n      dropdownClassName = _ref.dropdownClassName,\n      dropDownLength = _ref.dropDownLength,\n      value = _ref.value,\n      inputClassName = _ref.inputClassName,\n      itemClassName = _ref.itemClassName,\n      match = _ref.match,\n      onDropdownClose = _ref.onDropdownClose,\n      onDropdownOpen = _ref.onDropdownOpen,\n      onInput = _ref.onInput,\n      onSelect = _ref.onSelect,\n      onClick = _ref.onClick,\n      placeholder = _ref.placeholder,\n      requiredInputLength = _ref.requiredInputLength,\n      suppressReselect = _ref.suppressReselect,\n      items = _ref.items;\n\n  /*  last valid item that was selected from the drop down menu */\n  var _useState = React.useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      lastValidItem = _useState2[0],\n      setLastValidItem = _useState2[1];\n  /* current input text */\n\n\n  var _useStateRef = useStateRef(value !== undefined ? value : ''),\n      _useStateRef2 = _slicedToArray(_useStateRef, 3),\n      currentInput = _useStateRef2[0],\n      setCurrentInput = _useStateRef2[1],\n      currentInputRef = _useStateRef2[2];\n  /* current set of matching items */\n\n\n  var _useState3 = React.useState([]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      matchingItems = _useState4[0],\n      setMatchingItems = _useState4[1];\n  /* visibility property of the drop down menu */\n\n\n  var _useStateRef3 = useStateRef(false),\n      _useStateRef4 = _slicedToArray(_useStateRef3, 3),\n      visible = _useStateRef4[0],\n      setVisible = _useStateRef4[1],\n      visibleRef = _useStateRef4[2];\n  /* index of the currently focused item in the drop down menu */\n\n\n  var _useState5 = React.useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      focusIndex = _useState6[0],\n      setFocusIndex = _useState6[1];\n  /* cleaner click events, click interaction within dropdown menu */\n\n\n  var interactionHappenedRef = React.useRef(false);\n  /* show loader if still matching in debounced mode */\n\n  var _useState7 = React.useState(false),\n      _useState8 = _slicedToArray(_useState7, 2),\n      isMatchingDebounced = _useState8[0],\n      setIsMatchingDebounced = _useState8[1];\n  /* to manage debouncing of matching, typing input into the input field */\n\n\n  var inputHappenedTimeout = React.useRef();\n  var menu = React.useRef();\n  var inputField = React.useRef();\n  React.useEffect(function () {\n    var onClickCloseMenu = function onClickCloseMenu(event) {\n      if (!menu.current) return; // if rerender, items inside might change, allow one click without further checking\n\n      if (interactionHappenedRef.current) {\n        interactionHappenedRef.current = false;\n        return;\n      } // do not do anything if input is clicked, as we have a dedicated func for that\n\n\n      if (!inputField.current) return;\n      var targetIsInput = event.target === inputField.current;\n      var targetInInput = inputField.current.contains(event.target);\n      if (targetIsInput || targetInInput) return; // do not close menu if user clicked inside\n\n      var targetInMenu = menu.current.contains(event.target);\n      var targetIsMenu = event.target === menu.current;\n      if (targetInMenu || targetIsMenu) return;\n\n      if (visibleRef.current) {\n        setVisible(false);\n        setFocusIndex(-1);\n        onDropdownClose();\n      }\n    };\n\n    window.addEventListener('click', onClickCloseMenu, false);\n    return function () {\n      window.removeEventListener('click', onClickCloseMenu);\n    };\n  }, [onDropdownClose, setVisible, visibleRef]);\n  React.useEffect(function () {\n    // the parent component can pass its own value prop that will override the internally used currentInput\n    // this will happen only after we are have finished the current computing step and the dropdown is invisible\n    // (to avoid confusion of changing input values for the user)\n\n    /*\n     * we have to distinguish undefined and empty string value\n     * value == undefined => not set, use internal current input\n     * value !== undefined => value set, use value and override currentInput\n     * this enables value === '' to clear the input field\n     */\n    var isValuePropSet = value !== undefined;\n    var isValueDifferent = currentInputRef.current !== value;\n    var isMatchingRunning = visible || isMatchingDebounced;\n\n    if (isValuePropSet && isValueDifferent && !isMatchingRunning) {\n      setCurrentInput(value);\n    }\n  }, [visible, isMatchingDebounced, value, setCurrentInput, currentInputRef]);\n  /**\n   * runs the matching process of the current input\n   * and handles debouncing the different callback calls to reduce lag time\n   * for bigger datasets or heavier matching algorithms\n   * @param nextInput\n   */\n\n  var debouncedMatchingUpdateStep = React.useCallback(function (nextInput) {\n    // cleanup waiting update step\n    if (inputHappenedTimeout.current) {\n      clearTimeout(inputHappenedTimeout.current);\n      inputHappenedTimeout.current = null;\n    } // set nextInput into input field and show loading if debounced mode is on\n\n\n    var reachedRequiredLength = nextInput.length >= requiredInputLength;\n    var showMatchingStillLoading = debounceTime >= 0 && reachedRequiredLength;\n    setCurrentInput(nextInput);\n    setIsMatchingDebounced(showMatchingStillLoading); // no matching if we do not reach required input length\n\n    if (!reachedRequiredLength) return;\n\n    var updateMatchingItems = function updateMatchingItems() {\n      // matching process to find matching entries in items array\n      var updatedMatchingItems = items.filter(function (item) {\n        if (_typeof(match) === (typeof Function === \"undefined\" ? \"undefined\" : _typeof(Function))) return match(nextInput, item);\n        return labelMatch(nextInput, item);\n      });\n      var displayableItems = updatedMatchingItems.slice(0, dropDownLength);\n      var showDragIndex = lastValidItem && !clearInputOnSelect;\n      var index = showDragIndex ? indexOfItem(lastValidItem, displayableItems) : 0;\n\n      if (displayableItems.length) {\n        if (!visibleRef.current) {\n          onDropdownOpen();\n        }\n\n        setMatchingItems(displayableItems);\n        setFocusIndex(index > 0 ? index : 0);\n        setIsMatchingDebounced(false);\n        setVisible(true);\n      } else {\n        if (visibleRef.current) {\n          setVisible(false);\n          onDropdownClose();\n        }\n\n        setMatchingItems(displayableItems);\n        setFocusIndex(-1);\n        setIsMatchingDebounced(false);\n      }\n    };\n\n    if (debounceTime <= 0) {\n      updateMatchingItems();\n    } else {\n      inputHappenedTimeout.current = setTimeout(updateMatchingItems, debounceTime);\n    }\n  }, [requiredInputLength, debounceTime, setCurrentInput, items, dropDownLength, lastValidItem, clearInputOnSelect, match, setVisible, onDropdownOpen, visibleRef, onDropdownClose]);\n  /**\n   * gets called when someone starts to write in the input field\n   * @param event\n   */\n\n  var onHandleInput = React.useCallback(function (event) {\n    var newValue = event.target.value;\n    debouncedMatchingUpdateStep(newValue);\n    onInput(newValue);\n  }, [debouncedMatchingUpdateStep, onInput]);\n  var onClickInput = React.useCallback(function () {\n    var currentValue = currentInputRef.current; // if user clicks on input field with value,\n    // the user most likely wants to clear the input field\n\n    if (currentValue && clearInputOnClick) {\n      currentValue = '';\n    }\n\n    onClick(currentValue);\n    var reachedRequiredLength = currentValue.length >= requiredInputLength;\n\n    if (reachedRequiredLength && !visibleRef.current) {\n      debouncedMatchingUpdateStep(currentValue);\n    }\n  }, [currentInputRef, clearInputOnClick, onClick, requiredInputLength, visibleRef, debouncedMatchingUpdateStep]);\n  /**\n   * handleSelect is called onClickItem and onEnter upon an option of the drop down menu\n   * does nothing if the key has not changed since the last onSelect event\n   * @param selectedItem\n   */\n\n  var onHandleSelect = React.useCallback(function (selectedItem) {\n    // block select call until last matching went through\n    if (isMatchingDebounced) return;\n    setCurrentInput(clearInputOnSelect ? '' : selectedItem.label);\n    setVisible(false);\n    setFocusIndex(-1);\n    interactionHappenedRef.current = true;\n    onDropdownClose();\n\n    if (suppressReselect && lastValidItem && selectedItem.key === lastValidItem.key) {\n      // do not trigger the callback function\n      // but still change state to fit new selection\n      return;\n    } // change state to fit new selection\n\n\n    setLastValidItem(selectedItem); // callback function onSelect\n\n    onSelect(selectedItem);\n  }, [isMatchingDebounced, setCurrentInput, clearInputOnSelect, setVisible, onDropdownClose, suppressReselect, lastValidItem, onSelect]);\n  /**\n   * handle key events\n   * @param event\n   */\n\n  var onHandleKeydown = React.useCallback(function (event) {\n    // only do something if drop-down div is visible\n    if (!visibleRef.current) return;\n    var currentFocusIndex = focusIndex;\n\n    if (event.keyCode === 40 || event.keyCode === 9) {\n      // If the arrow DOWN key or tab is pressed increase the currentFocus variable:\n      currentFocusIndex += 1;\n      if (currentFocusIndex >= matchingItems.length) currentFocusIndex = 0;\n      setFocusIndex(currentFocusIndex); // prevent tab to jump to the next input field if drop down is still open\n\n      event.preventDefault();\n    } else if (event.keyCode === 38) {\n      // If the arrow UP key is pressed, decrease the currentFocus variable:\n      currentFocusIndex -= 1;\n      if (currentFocusIndex <= -1) currentFocusIndex = matchingItems.length - 1;\n      setFocusIndex(currentFocusIndex);\n    } else if (event.keyCode === 13) {\n      // Enter pressed, similar to onClickItem\n      if (focusIndex > -1) {\n        // Simulate a click on the \"active\" item:\n        var selectedItem = matchingItems[currentFocusIndex];\n        onHandleSelect(selectedItem);\n      }\n    }\n  }, [focusIndex, matchingItems, onHandleSelect, visibleRef]);\n  var renderItemLabel = React.useCallback(function (item) {\n    var index = indexOfMatch(currentInput, item);\n    var inputLength = currentInput.length;\n    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, index >= 0 && inputLength ?\n    /*#__PURE__*/\n    // renders label with matching search string marked\n    React__default.createElement(React__default.Fragment, null, item.label.substr(0, index), /*#__PURE__*/React__default.createElement(\"strong\", null, item.label.substr(index, inputLength)), item.label.substr(index + inputLength, item.label.length)) : item.label);\n  }, [currentInput]);\n  var renderItems = React.useCallback(function () {\n    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, matchingItems.map(function (item, i) {\n      var isActive = focusIndex === i;\n      var itemActiveClasses = isActive ? \"datalist-active-item \".concat(activeItemClassName || 'datalist-active-item-default') : '';\n      var itemClasses = \"\".concat(itemClassName, \" \").concat(itemActiveClasses);\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        onClick: function onClick() {\n          return onHandleSelect(item);\n        },\n        className: itemClasses,\n        key: item.key,\n        tabIndex: 0,\n        role: \"button\",\n        \"aria-label\": item.label,\n        onKeyUp: function onKeyUp(event) {\n          return event.preventDefault();\n        }\n      }, renderItemLabel(item));\n    }));\n  }, [matchingItems, focusIndex, activeItemClassName, itemClassName, onHandleSelect, renderItemLabel]);\n  var dropDown = React.useMemo(function () {\n    var reachedRequiredLength = currentInputRef.current.length >= requiredInputLength;\n\n    if (reachedRequiredLength && isMatchingDebounced) {\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        ref: menu,\n        className: \"datalist-items \".concat(dropdownClassName || 'default-datalist-items'),\n        role: \"dialog\",\n        \"aria-label\": \"Dropdown menu\"\n      }, /*#__PURE__*/React__default.createElement(\"div\", {\n        className: itemClassName\n      }, debounceLoader || 'loading...'));\n    }\n\n    if (reachedRequiredLength && visible) {\n      return /*#__PURE__*/React__default.createElement(\"div\", {\n        ref: menu,\n        className: \"datalist-items \".concat(dropdownClassName || 'default-datalist-items'),\n        role: \"dialog\",\n        \"aria-label\": \"Dropdown menu\"\n      }, renderItems());\n    }\n\n    return undefined;\n  }, [currentInputRef, requiredInputLength, isMatchingDebounced, visible, dropdownClassName, itemClassName, debounceLoader, renderItems]);\n  return /*#__PURE__*/React__default.createElement(\"div\", {\n    className: \"datalist-input\"\n  }, /*#__PURE__*/React__default.createElement(\"input\", {\n    ref: inputField,\n    onChange: onHandleInput,\n    onClick: onClickInput,\n    onKeyDown: onHandleKeydown,\n    type: \"text\",\n    className: \"autocomplete-input \".concat(inputClassName),\n    placeholder: placeholder,\n    value: currentInput,\n    \"aria-label\": \"Search\"\n  }), dropDown);\n};\n\nDataListInput.propTypes = {\n  items: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.string.isRequired,\n    key: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired\n  })).isRequired,\n  placeholder: PropTypes.string,\n  onSelect: PropTypes.func.isRequired,\n  onDropdownOpen: PropTypes.func,\n  onDropdownClose: PropTypes.func,\n  match: PropTypes.func,\n  inputClassName: PropTypes.string,\n  dropdownClassName: PropTypes.string,\n  itemClassName: PropTypes.string,\n  activeItemClassName: PropTypes.string,\n  requiredInputLength: PropTypes.number,\n  clearInputOnSelect: PropTypes.bool,\n  clearInputOnClick: PropTypes.bool,\n  suppressReselect: PropTypes.bool,\n  dropDownLength: PropTypes.number,\n  value: PropTypes.string,\n  debounceTime: PropTypes.number,\n  debounceLoader: PropTypes.node,\n  onInput: PropTypes.func,\n  onClick: PropTypes.func\n};\nDataListInput.defaultProps = {\n  placeholder: '',\n  match: undefined,\n  inputClassName: '',\n  dropdownClassName: '',\n  itemClassName: '',\n  activeItemClassName: '',\n  requiredInputLength: 0,\n  clearInputOnSelect: false,\n  clearInputOnClick: false,\n  suppressReselect: true,\n  dropDownLength: Infinity,\n  value: undefined,\n  debounceTime: 0,\n  debounceLoader: undefined,\n  onDropdownOpen: function onDropdownOpen() {},\n  onDropdownClose: function onDropdownClose() {},\n  onInput: function onInput() {},\n  onClick: function onClick() {}\n};\n\nexports.default = DataListInput;\n//# sourceMappingURL=DataListInput.js.map\n"]},"metadata":{},"sourceType":"script"}